<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/apps/bot/models.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/bot/models.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Models for the Kuku AI Bot application&#10;&quot;&quot;&quot;&#10;import asyncio&#10;&#10;from django.core.exceptions import ValidationError&#10;from django.db import models&#10;from django.utils import timezone&#10;from django.utils.translation import gettext_lazy as _&#10;from telegram.error import TelegramError&#10;&#10;&#10;class GetOrNoneManager(models.Manager):&#10;    &quot;&quot;&quot;Custom manager that returns None instead of raising DoesNotExist&quot;&quot;&quot;&#10;&#10;    def get_or_none(self, **kwargs):&#10;        try:&#10;            return self.get(**kwargs)&#10;        except self.model.DoesNotExist:&#10;            return None&#10;&#10;&#10;class Language(models.TextChoices):&#10;    UZ = 'uz', _('Uzbek')&#10;    RU = 'ru', _('Russian')&#10;    EN = 'en', _('English')&#10;&#10;&#10;class SubscribeChannel(models.Model):&#10;    &quot;&quot;&quot;&#10;    Represents a Telegram channel that users must subscribe to.&#10;    &quot;&quot;&quot;&#10;    channel_username = models.CharField(max_length=100, unique=True, null=True, blank=True)&#10;    channel_link = models.URLField(max_length=255, blank=True, null=True)&#10;    channel_id = models.CharField(max_length=100, unique=True)&#10;    active = models.BooleanField(default=True)&#10;    private = models.BooleanField(default=False)&#10;    created_at = models.DateTimeField(auto_now_add=True)&#10;    updated_at = models.DateTimeField(auto_now=True)&#10;&#10;    class Meta:&#10;        verbose_name = _(&quot;Subscription Channel&quot;)&#10;        verbose_name_plural = _(&quot;Subscription Channels&quot;)&#10;        ordering = [&quot;-created_at&quot;]&#10;&#10;    def __str__(self):&#10;        return self.channel_username or self.channel_id&#10;&#10;    def clean(self):&#10;        &quot;&quot;&quot;&#10;        Custom validation for the model.&#10;        &quot;&quot;&quot;&#10;        if self.private and not self.channel_link:&#10;            raise ValidationError(_(&quot;A private channel must have an invitation link.&quot;))&#10;        if not self.private and not self.channel_username:&#10;            raise ValidationError(_(&quot;A public channel must have a username.&quot;))&#10;&#10;        # Check if bot is admin in channel using token from .env&#10;        from django.conf import settings&#10;        bot_token = getattr(settings, 'BOT_TOKEN', None)&#10;        if bot_token and self.channel_id:&#10;            try:&#10;                # Synchronous check using asyncio.run&#10;                is_admin = asyncio.run(&#10;                    self.some_method_that_uses_check_bot_is_admin(bot_token)&#10;                )&#10;                print(f&quot;Admin status for {self.channel_id}: {is_admin}&quot;)&#10;&#10;                if not is_admin:&#10;                    raise ValidationError(&#10;                        _(&quot;The bot is not an administrator in the specified channel. Please add the bot as an admin and try again.&quot;)&#10;                    )&#10;            except TelegramError as e:&#10;                raise ValidationError(&#10;                    _(&quot;Failed to verify bot admin status: {error}&quot;).format(error=str(e))&#10;                )&#10;&#10;    def save(self, *args, **kwargs):&#10;        &quot;&quot;&quot;Override save to ensure clean validation runs&quot;&quot;&quot;&#10;        self.clean()&#10;        super().save(*args, **kwargs)&#10;&#10;    def some_method_that_uses_check_bot_is_admin(self, bot_token):&#10;        from .utils import check_bot_is_admin_in_channel  # Local import to avoid circular import&#10;        return check_bot_is_admin_in_channel(self.channel_id, bot_token)&#10;&#10;&#10;class User(models.Model):&#10;    &quot;&quot;&quot;&#10;    Represents a Telegram user who interacts with the bot.&#10;    &quot;&quot;&quot;&#10;    telegram_id = models.BigIntegerField(unique=True, help_text=_(&quot;Telegram user ID&quot;))&#10;    first_name = models.CharField(max_length=100, blank=True, null=True)&#10;    last_name = models.CharField(max_length=100, blank=True, null=True)&#10;    username = models.CharField(max_length=100, blank=True, null=True)&#10;    last_active = models.DateTimeField(auto_now=True)&#10;    is_admin = models.BooleanField(default=False)&#10;    is_blocked = models.BooleanField(default=False)&#10;    created_at = models.DateTimeField(auto_now_add=True)&#10;    updated_at = models.DateTimeField(auto_now=True)&#10;    stock_language = models.CharField(max_length=10, choices=Language.choices, default=Language.UZ)&#10;    selected_language = models.CharField(max_length=10, choices=Language.choices, null=True, blank=True)&#10;    deeplink = models.TextField(blank=True, null=True)&#10;    left = models.BooleanField(default=False)&#10;    search_mode = models.CharField(&#10;        max_length=10,&#10;        choices=[(&quot;normal&quot;, &quot;Normal&quot;), (&quot;deep&quot;, &quot;Deep&quot;)],&#10;        default=&quot;normal&quot;&#10;    )&#10;&#10;    class Meta:&#10;        verbose_name = _(&quot;User&quot;)&#10;        verbose_name_plural = _(&quot;Users&quot;)&#10;&#10;    def __str__(self):&#10;        return f&quot;{self.full_name} ({self.telegram_id})&quot;&#10;&#10;    @property&#10;    def full_name(self) -&gt; str:&#10;        &quot;&quot;&quot;Returns the user's full name.&quot;&quot;&quot;&#10;        return f&quot;{self.first_name or ''} {self.last_name or ''}&quot;.strip()&#10;&#10;    def get_absolute_url(self):&#10;        &quot;&quot;&quot;Returns the URL to access a particular user instance.&quot;&quot;&quot;&#10;        from django.urls import reverse&#10;        return reverse('admin:bot_user_change', args=[str(self.id)])&#10;&#10;&#10;class Location(models.Model):&#10;    &quot;&quot;&quot;&#10;    Stores location data sent by a user.&#10;    &quot;&quot;&quot;&#10;    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name=&quot;locations&quot;)&#10;    latitude = models.FloatField()&#10;    longitude = models.FloatField()&#10;    created_at = models.DateTimeField(auto_now_add=True)&#10;&#10;    objects = GetOrNoneManager()&#10;&#10;    class Meta:&#10;        verbose_name = _(&quot;Location&quot;)&#10;        verbose_name_plural = _(&quot;Locations&quot;)&#10;        ordering = [&quot;-created_at&quot;]&#10;&#10;    def __str__(self):&#10;        return f&quot;Location for {self.user} at {self.created_at.strftime('(%H:%M, %d %B %Y)')}&quot;&#10;&#10;&#10;class Broadcast(models.Model):&#10;    class Status(models.TextChoices):&#10;        DRAFT = 'draft', _('Draft')&#10;        PENDING = 'pending', _('Pending')&#10;        IN_PROGRESS = 'in_progress', _('In Progress')&#10;        COMPLETED = 'completed', _('Completed')&#10;&#10;    from_chat_id = models.BigIntegerField()&#10;    message_id = models.BigIntegerField()&#10;    created_at = models.DateTimeField(auto_now_add=True)&#10;    scheduled_time = models.DateTimeField(default=timezone.now)&#10;    status = models.CharField(max_length=20, choices=Status.choices, default=Status.DRAFT)&#10;&#10;    def __str__(self):&#10;        return f&quot;Forward {self.message_id} from {self.from_chat_id}&quot;&#10;&#10;&#10;class BroadcastRecipient(models.Model):&#10;    class Status(models.TextChoices):&#10;        PENDING = 'pending', _('Pending')&#10;        SENT = 'sent', _('Sent')&#10;        FAILED = 'failed', _('Failed')&#10;&#10;    broadcast = models.ForeignKey(Broadcast, on_delete=models.CASCADE, related_name=&quot;recipients&quot;)&#10;    user = models.ForeignKey('User', on_delete=models.CASCADE, related_name=&quot;broadcast_messages&quot;)&#10;    status = models.CharField(max_length=10, choices=Status.choices, default=Status.PENDING)&#10;    error_message = models.TextField(blank=True, null=True)&#10;    sent_at = models.DateTimeField(blank=True, null=True)&#10;&#10;    class Meta:&#10;        unique_together = ('broadcast', 'user')&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Models for the Kuku AI Bot application&#10;&quot;&quot;&quot;&#10;import asyncio&#10;&#10;from django.core.exceptions import ValidationError&#10;from django.db import models&#10;from django.utils import timezone&#10;from django.utils.translation import gettext_lazy as _&#10;from telegram.error import TelegramError&#10;&#10;&#10;class GetOrNoneManager(models.Manager):&#10;    &quot;&quot;&quot;Custom manager that returns None instead of raising DoesNotExist&quot;&quot;&quot;&#10;&#10;    def get_or_none(self, **kwargs):&#10;        try:&#10;            return self.get(**kwargs)&#10;        except self.model.DoesNotExist:&#10;            return None&#10;&#10;&#10;class Language(models.TextChoices):&#10;    UZ = 'uz', _('Uzbek')&#10;    RU = 'ru', _('Russian')&#10;    EN = 'en', _('English')&#10;&#10;&#10;class SubscribeChannel(models.Model):&#10;    &quot;&quot;&quot;&#10;    Represents a Telegram channel that users must subscribe to.&#10;    &quot;&quot;&quot;&#10;    channel_username = models.CharField(max_length=100, unique=True, null=True, blank=True)&#10;    channel_link = models.URLField(max_length=255, blank=True, null=True)&#10;    channel_id = models.CharField(max_length=100, unique=True)&#10;    active = models.BooleanField(default=True)&#10;    private = models.BooleanField(default=False)&#10;    created_at = models.DateTimeField(auto_now_add=True)&#10;    updated_at = models.DateTimeField(auto_now=True)&#10;&#10;    class Meta:&#10;        verbose_name = _(&quot;Subscription Channel&quot;)&#10;        verbose_name_plural = _(&quot;Subscription Channels&quot;)&#10;        ordering = [&quot;-created_at&quot;]&#10;&#10;    def __str__(self):&#10;        return self.channel_username or self.channel_id&#10;&#10;    def clean(self):&#10;        &quot;&quot;&quot;&#10;        Custom validation for the model.&#10;        &quot;&quot;&quot;&#10;        if self.private and not self.channel_link:&#10;            raise ValidationError(_(&quot;A private channel must have an invitation link.&quot;))&#10;        if not self.private and not self.channel_username:&#10;            raise ValidationError(_(&quot;A public channel must have a username.&quot;))&#10;&#10;        # Check if bot is admin in channel using token from .env&#10;        from django.conf import settings&#10;        bot_token = getattr(settings, 'BOT_TOKEN', None)&#10;        if bot_token and self.channel_id:&#10;            try:&#10;                # Synchronous check using asyncio.run&#10;                is_admin = asyncio.run(&#10;                    self.some_method_that_uses_check_bot_is_admin(bot_token)&#10;                )&#10;                print(f&quot;Admin status for {self.channel_id}: {is_admin}&quot;)&#10;&#10;                if not is_admin:&#10;                    raise ValidationError(&#10;                        _(&quot;The bot is not an administrator in the specified channel. Please add the bot as an admin and try again.&quot;)&#10;                    )&#10;            except TelegramError as e:&#10;                raise ValidationError(&#10;                    _(&quot;Failed to verify bot admin status: {error}&quot;).format(error=str(e))&#10;                )&#10;&#10;    def save(self, *args, **kwargs):&#10;        &quot;&quot;&quot;Override save to ensure clean validation runs&quot;&quot;&quot;&#10;        self.clean()&#10;        super().save(*args, **kwargs)&#10;&#10;    def some_method_that_uses_check_bot_is_admin(self, bot_token):&#10;        from .utils import check_bot_is_admin_in_channel  # Local import to avoid circular import&#10;        return check_bot_is_admin_in_channel(self.channel_id, bot_token)&#10;&#10;&#10;class User(models.Model):&#10;    &quot;&quot;&quot;&#10;    Represents a Telegram user who interacts with the bot.&#10;    &quot;&quot;&quot;&#10;    telegram_id = models.BigIntegerField(unique=True, db_index=True, help_text=_(&quot;Telegram user ID&quot;))&#10;    first_name = models.CharField(max_length=100, blank=True, null=True)&#10;    last_name = models.CharField(max_length=100, blank=True, null=True)&#10;    username = models.CharField(max_length=100, blank=True, null=True)&#10;    last_active = models.DateTimeField(auto_now=True, db_index=True)&#10;    is_admin = models.BooleanField(default=False)&#10;    is_blocked = models.BooleanField(default=False)&#10;    created_at = models.DateTimeField(auto_now_add=True)&#10;    updated_at = models.DateTimeField(auto_now=True)&#10;    stock_language = models.CharField(max_length=10, choices=Language.choices, default=Language.UZ)&#10;    selected_language = models.CharField(max_length=10, choices=Language.choices, null=True, blank=True)&#10;    deeplink = models.TextField(blank=True, null=True)&#10;    left = models.BooleanField(default=False)&#10;    search_mode = models.CharField(&#10;        max_length=10,&#10;        choices=[(&quot;normal&quot;, &quot;Normal&quot;), (&quot;deep&quot;, &quot;Deep&quot;)],&#10;        default=&quot;normal&quot;,&#10;        db_index=True&#10;    )&#10;&#10;    class Meta:&#10;        verbose_name = _(&quot;User&quot;)&#10;        verbose_name_plural = _(&quot;Users&quot;)&#10;&#10;    def __str__(self):&#10;        return f&quot;{self.full_name} ({self.telegram_id})&quot;&#10;&#10;    @property&#10;    def full_name(self) -&gt; str:&#10;        &quot;&quot;&quot;Returns the user's full name.&quot;&quot;&quot;&#10;        return f&quot;{self.first_name or ''} {self.last_name or ''}&quot;.strip()&#10;&#10;    def get_absolute_url(self):&#10;        &quot;&quot;&quot;Returns the URL to access a particular user instance.&quot;&quot;&quot;&#10;        from django.urls import reverse&#10;        return reverse('admin:bot_user_change', args=[str(self.id)])&#10;&#10;&#10;class Location(models.Model):&#10;    &quot;&quot;&quot;&#10;    Stores location data sent by a user.&#10;    &quot;&quot;&quot;&#10;    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name=&quot;locations&quot;)&#10;    latitude = models.FloatField()&#10;    longitude = models.FloatField()&#10;    created_at = models.DateTimeField(auto_now_add=True)&#10;&#10;    objects = GetOrNoneManager()&#10;&#10;    class Meta:&#10;        verbose_name = _(&quot;Location&quot;)&#10;        verbose_name_plural = _(&quot;Locations&quot;)&#10;        ordering = [&quot;-created_at&quot;]&#10;&#10;    def __str__(self):&#10;        return f&quot;Location for {self.user} at {self.created_at.strftime('(%H:%M, %d %B %Y)')}&quot;&#10;&#10;&#10;class Broadcast(models.Model):&#10;    class Status(models.TextChoices):&#10;        DRAFT = 'draft', _('Draft')&#10;        PENDING = 'pending', _('Pending')&#10;        IN_PROGRESS = 'in_progress', _('In Progress')&#10;        COMPLETED = 'completed', _('Completed')&#10;&#10;    from_chat_id = models.BigIntegerField()&#10;    message_id = models.BigIntegerField()&#10;    created_at = models.DateTimeField(auto_now_add=True)&#10;    scheduled_time = models.DateTimeField(default=timezone.now)&#10;    status = models.CharField(max_length=20, choices=Status.choices, default=Status.DRAFT)&#10;&#10;    def __str__(self):&#10;        return f&quot;Forward {self.message_id} from {self.from_chat_id}&quot;&#10;&#10;&#10;class BroadcastRecipient(models.Model):&#10;    class Status(models.TextChoices):&#10;        PENDING = 'pending', _('Pending')&#10;        SENT = 'sent', _('Sent')&#10;        FAILED = 'failed', _('Failed')&#10;&#10;    broadcast = models.ForeignKey(Broadcast, on_delete=models.CASCADE, related_name=&quot;recipients&quot;)&#10;    user = models.ForeignKey('User', on_delete=models.CASCADE, related_name=&quot;broadcast_messages&quot;)&#10;    status = models.CharField(max_length=10, choices=Status.choices, default=Status.PENDING, db_index=True)&#10;    error_message = models.TextField(blank=True, null=True)&#10;    sent_at = models.DateTimeField(blank=True, null=True)&#10;&#10;    class Meta:&#10;        unique_together = ('broadcast', 'user')" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/files/models.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/files/models.py" />
              <option name="originalContent" value="import uuid&#10;from django.db import models&#10;&#10;&#10;def upload_to(instance, filename):&#10;    &quot;&quot;&quot;Generate upload path for files&quot;&quot;&quot;&#10;    return f'documents/{instance.id}/{filename}'&#10;&#10;&#10;class ParseProgress(models.Model):&#10;    &quot;&quot;&quot;Track parsing progress for continuous parsing&quot;&quot;&quot;&#10;    id = models.AutoField(primary_key=True)&#10;    last_page = models.IntegerField(default=0, verbose_name=&quot;Last Parsed Page&quot;)&#10;    total_pages_parsed = models.IntegerField(default=0, verbose_name=&quot;Total Pages Parsed&quot;)&#10;    last_run_at = models.DateTimeField(auto_now=True, verbose_name=&quot;Last Run At&quot;)&#10;    created_at = models.DateTimeField(auto_now_add=True, verbose_name=&quot;Created At&quot;)&#10;&#10;    class Meta:&#10;        verbose_name = &quot;Parse Progress&quot;&#10;        verbose_name_plural = &quot;Parse Progress&quot;&#10;        ordering = ['-last_run_at']&#10;&#10;    def __str__(self):&#10;        return f&quot;Last Page: {self.last_page}, Total: {self.total_pages_parsed}&quot;&#10;&#10;    @classmethod&#10;    def get_current_progress(cls):&#10;        &quot;&quot;&quot;Get current parsing progress&quot;&quot;&quot;&#10;        progress, created = cls.objects.get_or_create(&#10;            defaults={'last_page': 0, 'total_pages_parsed': 0}&#10;        )&#10;        return progress&#10;&#10;    def update_progress(self, page_number):&#10;        &quot;&quot;&quot;Update parsing progress&quot;&quot;&quot;&#10;        self.last_page = page_number&#10;        self.total_pages_parsed += 1&#10;        self.save()&#10;&#10;&#10;&#10;class Document(models.Model):&#10;    STATUS_CHOICES = [&#10;        ('pending', 'Kutilmoqda'),&#10;        ('processing', 'Jarayonda'),&#10;        ('completed', 'Tugatildi'),&#10;        ('failed', 'Xatolik'),&#10;        ('skipped', 'O`tkazib yuborildi'),&#10;    ]&#10;&#10;    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False,db_index=True)&#10;&#10;    parse_file_url = models.TextField(blank=True, null=True, verbose_name=&quot;File URL&quot;,&#10;                                help_text=&quot;Direct link to the document file&quot;)&#10;    #status&#10;    download_status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending',&#10;                                       verbose_name=&quot;Yuklab olish holati&quot;)&#10;    parse_status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending',&#10;                                    verbose_name=&quot;Parse qilish holati&quot;)&#10;    index_status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending',&#10;                                    verbose_name=&quot;Indekslash holati&quot;)&#10;    telegram_status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending',&#10;                                       verbose_name=&quot;Telegram holati&quot;)&#10;    delete_status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending',&#10;                                     verbose_name=&quot;O'chirish holati&quot;)&#10;&#10;    completed = models.BooleanField(default=False, verbose_name=&quot;Barchasi tugatildimi?&quot;,db_index=True)&#10;&#10;    telegram_file_id = models.CharField(blank=True, null=True, verbose_name=&quot;Telegram File ID&quot;,&#10;                                        help_text=&quot;File ID after sending to Telegram channel&quot;,db_index=True,max_length=500)&#10;    created_at = models.DateTimeField(auto_now_add=True, verbose_name=&quot;Created At&quot;,db_index=True)&#10;    updated_at = models.DateTimeField(auto_now=True, verbose_name=&quot;Updated At&quot;)&#10;    json_data = models.JSONField(blank=True, null=True, verbose_name=&quot;JSON Data&quot;)&#10;    pipeline_running = models.BooleanField(default=False, db_index=True, help_text=&quot;Pipeline hozir ushbu hujjat ustida ishlayotganini bildiradi&quot;)&#10;&#10;    class Meta:&#10;        verbose_name = &quot;Document&quot;&#10;        verbose_name_plural = &quot;Documents&quot;&#10;        ordering = ['-created_at']&#10;&#10;    def save(self, *args, **kwargs):&#10;        # IDEAL HOLAT QOIDASI: &#10;        # 1. document.product.parsed_content mavjud va bo'sh emas&#10;        # 2. telegram_file_id mavjud va bo'sh emas  &#10;        # 3. pipeline_running = False&#10;        # 4. index_status = 'completed'&#10;        &#10;        has_parsed_content = (&#10;            hasattr(self, 'product') and &#10;            self.product is not None and &#10;            self.product.parsed_content is not None and &#10;            self.product.parsed_content.strip() != ''&#10;        )&#10;        &#10;        has_telegram_file = (&#10;            self.telegram_file_id is not None and &#10;            self.telegram_file_id.strip() != ''&#10;        )&#10;        &#10;        is_indexed = (self.index_status == 'completed')&#10;        pipeline_not_running = (not self.pipeline_running)&#10;        &#10;        # BARCHA 4 SHART bajarilgan bo'lsa - IDEAL HOLAT&#10;        if has_parsed_content and has_telegram_file and is_indexed and pipeline_not_running:&#10;            # Completed = True va barcha statuslarni completed qilish&#10;            self.completed = True&#10;            self.pipeline_running = False&#10;            self.download_status = 'completed'&#10;            self.parse_status = 'completed' &#10;            self.index_status = 'completed'&#10;            self.telegram_status = 'completed'&#10;            self.delete_status = 'completed'&#10;        else:&#10;            # Ideal holatda bo'lmasa, completed=False&#10;            self.completed = False&#10;        &#10;        super().save(*args, **kwargs)&#10;&#10;    def __str__(self):&#10;        return f&quot;Document {self.id} ({self.parse_file_url or 'no file'})&quot;&#10;&#10;&#10;class Product(models.Model):&#10;    &quot;&quot;&quot;Product model for digital products&quot;&quot;&quot;&#10;    id = models.IntegerField(primary_key=True, verbose_name=&quot;Product ID&quot;)&#10;    title = models.TextField(verbose_name=&quot;Title&quot;,db_index=True)&#10;    parsed_content = models.TextField(blank=True, null=True, verbose_name=&quot;Parsed Content&quot;)&#10;    slug = models.TextField(unique=True, verbose_name=&quot;Slug&quot;,db_index=True)&#10;    document = models.OneToOneField(Document, on_delete=models.CASCADE, related_name='product', verbose_name=&quot;Document&quot;)&#10;    view_count = models.PositiveIntegerField(default=0, verbose_name=&quot;View Count&quot;, db_index=True)&#10;    download_count = models.PositiveIntegerField(default=0, verbose_name=&quot;Download Count&quot;, db_index=True)&#10;    file_size = models.PositiveBigIntegerField(default=0, verbose_name=&quot;File Size (bytes)&quot;)&#10;    created_at = models.DateTimeField(auto_now_add=True, verbose_name=&quot;Created At&quot;,db_index=True)&#10;    updated_at = models.DateTimeField(auto_now=True, verbose_name=&quot;Updated At&quot;)&#10;&#10;&#10;    class Meta:&#10;        verbose_name = &quot;Product&quot;&#10;        verbose_name_plural = &quot;Products&quot;&#10;        ordering = ['-created_at']&#10;&#10;    def __str__(self):&#10;        return self.title&#10;&#10;&#10;&#10;class SiteToken(models.Model):&#10;    NAME_CHOICES = [&#10;        ('soff', 'soff'),&#10;        ('arxiv', 'arxiv'),&#10;    ]&#10;&#10;    name = models.CharField(choices=NAME_CHOICES, unique=True,max_length=100)&#10;    token = models.CharField(unique=True,max_length=300)&#10;    auth_token = models.TextField(blank=True, null=True)&#10;    created_at = models.DateTimeField(auto_now_add=True)&#10;    updated_at = models.DateTimeField(auto_now=True)&#10;&#10;    def __str__(self):&#10;        return self.name&#10;&#10;&#10;class DocumentError(models.Model):&#10;    &quot;&quot;&quot;Model to store errors that occur during document processing (download, telegram sending, etc.)&quot;&quot;&quot;&#10;    ERROR_TYPE_CHOICES = [&#10;        ('download', 'Yuklab olish xatoligi'),&#10;        ('telegram_send', 'Telegramga yuborish xatoligi'),&#10;        ('telegram_download', 'Telegramdan yuklab olish xatoligi'),&#10;        ('parse', 'Parse qilish xatoligi'),&#10;        ('index', 'Indekslash xatoligi'),&#10;        ('other', 'Boshqa xatolik'),&#10;    ]&#10;    &#10;    document = models.ForeignKey(Document, on_delete=models.CASCADE, related_name='errors', verbose_name=&quot;Document&quot;)&#10;    error_type = models.CharField(max_length=20, choices=ERROR_TYPE_CHOICES, verbose_name=&quot;Xatolik turi&quot;)&#10;    error_message = models.TextField(verbose_name=&quot;Xatolik xabari&quot;)&#10;    celery_attempt = models.PositiveIntegerField(default=1, verbose_name=&quot;Celery urinish raqami&quot;, help_text=&quot;Bu xatolik qaysi urinishda yuz bergani&quot;)&#10;    created_at = models.DateTimeField(auto_now_add=True, verbose_name=&quot;Yaratilgan vaqt&quot;)&#10;    &#10;    class Meta:&#10;        verbose_name = &quot;Document Error&quot;&#10;        verbose_name_plural = &quot;Document Errors&quot;&#10;        ordering = ['-created_at']&#10;    &#10;    def __str__(self):&#10;        return f&quot;{self.get_error_type_display()} - {self.document.id} (urinish: {self.celery_attempt})&quot;&#10;&#10;&#10;class SearchQuery(models.Model):&#10;    user = models.ForeignKey('bot.User', on_delete=models.CASCADE, related_name='search_queries')&#10;    query_text = models.CharField(max_length=500)&#10;    found_results = models.BooleanField(default=False)&#10;    is_deep_search = models.BooleanField(default=False)&#10;    created_at = models.DateTimeField(auto_now_add=True)&#10;&#10;    def __str__(self):&#10;        return f&quot;'{self.query_text}' by {self.user}&quot;&#10;&#10;&#10;def document_image_upload_to(instance, filename):&#10;    return f&quot;file/{instance.document.id}/{filename}&quot;&#10;&#10;&#10;class DocumentImage(models.Model):&#10;    document = models.ForeignKey(Document, on_delete=models.CASCADE, related_name='images')&#10;    page_number = models.PositiveIntegerField()&#10;    image = models.ImageField(upload_to=document_image_upload_to)&#10;    created_at = models.DateTimeField(auto_now_add=True)&#10;&#10;    class Meta:&#10;        unique_together = ('document', 'page_number')&#10;        ordering = ['page_number']&#10;&#10;    def __str__(self):&#10;        return f&quot;Image p{self.page_number} for {self.document_id}&quot;&#10;" />
              <option name="updatedContent" value="import uuid&#10;from django.db import models&#10;&#10;&#10;def upload_to(instance, filename):&#10;    &quot;&quot;&quot;Generate upload path for files&quot;&quot;&quot;&#10;    return f'documents/{instance.id}/{filename}'&#10;&#10;&#10;class ParseProgress(models.Model):&#10;    &quot;&quot;&quot;Track parsing progress for continuous parsing&quot;&quot;&quot;&#10;    id = models.AutoField(primary_key=True)&#10;    last_page = models.IntegerField(default=0, verbose_name=&quot;Last Parsed Page&quot;)&#10;    total_pages_parsed = models.IntegerField(default=0, verbose_name=&quot;Total Pages Parsed&quot;)&#10;    last_run_at = models.DateTimeField(auto_now=True, verbose_name=&quot;Last Run At&quot;)&#10;    created_at = models.DateTimeField(auto_now_add=True, verbose_name=&quot;Created At&quot;)&#10;&#10;    class Meta:&#10;        verbose_name = &quot;Parse Progress&quot;&#10;        verbose_name_plural = &quot;Parse Progress&quot;&#10;        ordering = ['-last_run_at']&#10;&#10;    def __str__(self):&#10;        return f&quot;Last Page: {self.last_page}, Total: {self.total_pages_parsed}&quot;&#10;&#10;    @classmethod&#10;    def get_current_progress(cls):&#10;        &quot;&quot;&quot;Get current parsing progress&quot;&quot;&quot;&#10;        progress, created = cls.objects.get_or_create(&#10;            defaults={'last_page': 0, 'total_pages_parsed': 0}&#10;        )&#10;        return progress&#10;&#10;    def update_progress(self, page_number):&#10;        &quot;&quot;&quot;Update parsing progress&quot;&quot;&quot;&#10;        self.last_page = page_number&#10;        self.total_pages_parsed += 1&#10;        self.save()&#10;&#10;&#10;&#10;class Document(models.Model):&#10;    STATUS_CHOICES = [&#10;        ('pending', 'Kutilmoqda'),&#10;        ('processing', 'Jarayonda'),&#10;        ('completed', 'Tugatildi'),&#10;        ('failed', 'Xatolik'),&#10;        ('skipped', 'O`tkazib yuborildi'),&#10;    ]&#10;&#10;    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False,db_index=True)&#10;&#10;    parse_file_url = models.TextField(blank=True, null=True, verbose_name=&quot;File URL&quot;,&#10;                                help_text=&quot;Direct link to the document file&quot;)&#10;    #status&#10;    download_status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending',&#10;                                       verbose_name=&quot;Yuklab olish holati&quot;, db_index=True)&#10;    parse_status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending',&#10;                                    verbose_name=&quot;Parse qilish holati&quot;, db_index=True)&#10;    index_status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending',&#10;                                    verbose_name=&quot;Indekslash holati&quot;, db_index=True)&#10;    telegram_status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending',&#10;                                       verbose_name=&quot;Telegram holati&quot;, db_index=True)&#10;    delete_status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending',&#10;                                     verbose_name=&quot;O'chirish holati&quot;, db_index=True)&#10;&#10;    completed = models.BooleanField(default=False, verbose_name=&quot;Barchasi tugatildimi?&quot;,db_index=True)&#10;&#10;    telegram_file_id = models.CharField(blank=True, null=True, verbose_name=&quot;Telegram File ID&quot;,&#10;                                        help_text=&quot;File ID after sending to Telegram channel&quot;,db_index=True,max_length=500)&#10;    created_at = models.DateTimeField(auto_now_add=True, verbose_name=&quot;Created At&quot;,db_index=True)&#10;    updated_at = models.DateTimeField(auto_now=True, verbose_name=&quot;Updated At&quot;, db_index=True)&#10;    json_data = models.JSONField(blank=True, null=True, verbose_name=&quot;JSON Data&quot;)&#10;    pipeline_running = models.BooleanField(default=False, db_index=True, help_text=&quot;Pipeline hozir ushbu hujjat ustida ishlayotganini bildiradi&quot;)&#10;&#10;    class Meta:&#10;        verbose_name = &quot;Document&quot;&#10;        verbose_name_plural = &quot;Documents&quot;&#10;        ordering = ['-created_at']&#10;&#10;    def save(self, *args, **kwargs):&#10;        # IDEAL HOLAT QOIDASI: &#10;        # 1. document.product.parsed_content mavjud va bo'sh emas&#10;        # 2. telegram_file_id mavjud va bo'sh emas  &#10;        # 3. pipeline_running = False&#10;        # 4. index_status = 'completed'&#10;        &#10;        has_parsed_content = (&#10;            hasattr(self, 'product') and &#10;            self.product is not None and &#10;            self.product.parsed_content is not None and &#10;            self.product.parsed_content.strip() != ''&#10;        )&#10;        &#10;        has_telegram_file = (&#10;            self.telegram_file_id is not None and &#10;            self.telegram_file_id.strip() != ''&#10;        )&#10;        &#10;        is_indexed = (self.index_status == 'completed')&#10;        pipeline_not_running = (not self.pipeline_running)&#10;        &#10;        # BARCHA 4 SHART bajarilgan bo'lsa - IDEAL HOLAT&#10;        if has_parsed_content and has_telegram_file and is_indexed and pipeline_not_running:&#10;            # Completed = True va barcha statuslarni completed qilish&#10;            self.completed = True&#10;            self.pipeline_running = False&#10;            self.download_status = 'completed'&#10;            self.parse_status = 'completed' &#10;            self.index_status = 'completed'&#10;            self.telegram_status = 'completed'&#10;            self.delete_status = 'completed'&#10;        else:&#10;            # Ideal holatda bo'lmasa, completed=False&#10;            self.completed = False&#10;        &#10;        super().save(*args, **kwargs)&#10;&#10;    def __str__(self):&#10;        return f&quot;Document {self.id} ({self.parse_file_url or 'no file'})&quot;&#10;&#10;&#10;class Product(models.Model):&#10;    &quot;&quot;&quot;Product model for digital products&quot;&quot;&quot;&#10;    id = models.IntegerField(primary_key=True, verbose_name=&quot;Product ID&quot;)&#10;    title = models.TextField(verbose_name=&quot;Title&quot;,db_index=True)&#10;    parsed_content = models.TextField(blank=True, null=True, verbose_name=&quot;Parsed Content&quot;)&#10;    slug = models.TextField(unique=True, verbose_name=&quot;Slug&quot;,db_index=True)&#10;    document = models.OneToOneField(Document, on_delete=models.CASCADE, related_name='product', verbose_name=&quot;Document&quot;)&#10;    view_count = models.PositiveIntegerField(default=0, verbose_name=&quot;View Count&quot;, db_index=True)&#10;    download_count = models.PositiveIntegerField(default=0, verbose_name=&quot;Download Count&quot;, db_index=True)&#10;    file_size = models.PositiveBigIntegerField(default=0, verbose_name=&quot;File Size (bytes)&quot;)&#10;    created_at = models.DateTimeField(auto_now_add=True, verbose_name=&quot;Created At&quot;,db_index=True)&#10;    updated_at = models.DateTimeField(auto_now=True, verbose_name=&quot;Updated At&quot;)&#10;&#10;&#10;    class Meta:&#10;        verbose_name = &quot;Product&quot;&#10;        verbose_name_plural = &quot;Products&quot;&#10;        ordering = ['-created_at']&#10;&#10;    def __str__(self):&#10;        return self.title&#10;&#10;&#10;&#10;class SiteToken(models.Model):&#10;    NAME_CHOICES = [&#10;        ('soff', 'soff'),&#10;        ('arxiv', 'arxiv'),&#10;    ]&#10;&#10;    name = models.CharField(choices=NAME_CHOICES, unique=True,max_length=100)&#10;    token = models.CharField(unique=True,max_length=300)&#10;    auth_token = models.TextField(blank=True, null=True)&#10;    created_at = models.DateTimeField(auto_now_add=True)&#10;    updated_at = models.DateTimeField(auto_now=True)&#10;&#10;    def __str__(self):&#10;        return self.name&#10;&#10;&#10;class DocumentError(models.Model):&#10;    &quot;&quot;&quot;Model to store errors that occur during document processing (download, telegram sending, etc.)&quot;&quot;&quot;&#10;    ERROR_TYPE_CHOICES = [&#10;        ('download', 'Yuklab olish xatoligi'),&#10;        ('telegram_send', 'Telegramga yuborish xatoligi'),&#10;        ('telegram_download', 'Telegramdan yuklab olish xatoligi'),&#10;        ('parse', 'Parse qilish xatoligi'),&#10;        ('index', 'Indekslash xatoligi'),&#10;        ('other', 'Boshqa xatolik'),&#10;    ]&#10;    &#10;    document = models.ForeignKey(Document, on_delete=models.CASCADE, related_name='errors', verbose_name=&quot;Document&quot;, db_index=True)&#10;    error_type = models.CharField(max_length=20, choices=ERROR_TYPE_CHOICES, verbose_name=&quot;Xatolik turi&quot;, db_index=True)&#10;    error_message = models.TextField(verbose_name=&quot;Xatolik xabari&quot;)&#10;    celery_attempt = models.PositiveIntegerField(default=1, verbose_name=&quot;Celery urinish raqami&quot;, help_text=&quot;Bu xatolik qaysi urinishda yuz bergani&quot;)&#10;    created_at = models.DateTimeField(auto_now_add=True, verbose_name=&quot;Yaratilgan vaqt&quot;, db_index=True)&#10;    &#10;    class Meta:&#10;        verbose_name = &quot;Document Error&quot;&#10;        verbose_name_plural = &quot;Document Errors&quot;&#10;        ordering = ['-created_at']&#10;    &#10;    def __str__(self):&#10;        return f&quot;{self.get_error_type_display()} - {self.document.id} (urinish: {self.celery_attempt})&quot;&#10;&#10;&#10;class SearchQuery(models.Model):&#10;    user = models.ForeignKey('bot.User', on_delete=models.CASCADE, related_name='search_queries', db_index=True)&#10;    query_text = models.CharField(max_length=500, db_index=True)&#10;    found_results = models.BooleanField(default=False, db_index=True)&#10;    is_deep_search = models.BooleanField(default=False, db_index=True)&#10;    created_at = models.DateTimeField(auto_now_add=True, db_index=True)&#10;&#10;    def __str__(self):&#10;        return f&quot;'{self.query_text}' by {self.user}&quot;&#10;&#10;&#10;def document_image_upload_to(instance, filename):&#10;    return f&quot;file/{instance.document.id}/{filename}&quot;&#10;&#10;&#10;class DocumentImage(models.Model):&#10;    document = models.ForeignKey(Document, on_delete=models.CASCADE, related_name='images')&#10;    page_number = models.PositiveIntegerField()&#10;    image = models.ImageField(upload_to=document_image_upload_to)&#10;    created_at = models.DateTimeField(auto_now_add=True)&#10;&#10;    class Meta:&#10;        unique_together = ('document', 'page_number')&#10;        ordering = ['page_number']&#10;&#10;    def __str__(self):&#10;        return f&quot;Image p{self.page_number} for {self.document_id}&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>